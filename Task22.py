'''
Task 22 Level 3 
References:
1. geeksforgeeks.org 
2. https://stackabuse.com/k-means-clustering-with-scikit-learn/
3. https://matplotlib.org/stable/gallery/subplots_axes_and_figures/subplots_demo.html
'''

# Numpy allows us to do the math to the data
from statistics import mean
import numpy as np
 
# csv does a similar function compared to pandas
import csv

# Matplotlib allows us to plot the graphs when it is time to plot nearer to the end of this task
import matplotlib.pyplot as plt

# And Finally random, because we use random to find and initialize the clusters that we need to calculate the distance to
import random 

def read_csv(file):

    ''' The function takes a name of a cvs file from user, reads it with csv reader, and returns a list''' 

    with open(file, 'r') as csvfile:
        next(csvfile)                # removes the header from csv file
        read = csv.reader(csvfile, delimiter = ',')      
        data_lst = []
        for row in read:       
            data_lst.append(row)
    return data_lst

def euclidean_dist_calc(dataSet1, random_xy): 

    ''' The function calculates euclidean distance between a randomly chosen point and each point in the data set. 
    It takes in the data set created after reading cvs file and returns a list with the euclidean distances'''

    eu_dist=[]          
    for i in range(0,len(dataSet1)):
        for j in range(0, len(random_xy)):        
            dist = round(np.sqrt((float(random_xy[j][0]) - float(dataSet1[i][1]))**2 + (float(random_xy[j][1]) -float(dataSet1[i][2]))**2), 2)
            eu_dist.append(dist)   
    return eu_dist
 
def init_clusters(dataSet1, num_of_clusters):

    '''The function intitializes the random points as centroids for initial clustering. It takes in data set created after reading csv file and returns a list with 
    randomly chosen from the data set points - initial centroids''' 

    X = []
    Y = []  
    for i in range(0,len(dataSet1)): 
        X.append(dataSet1[i][1]) # chooses birth rate (x value)
        Y.append(dataSet1[i][2]) # chooses life expectancy (y value)
  
    random_x = random.sample(X, num_of_clusters)    
    random_y = random.sample(Y, num_of_clusters)  
    random_xy = [list(l) for l in zip(random_x, random_y)]
    return (random_xy) 

def min_dist():

    ''' The function finds the min distance in the list of euclidean distances. It takes in the euclidean distances and splits the list into set of lists, 
    where each set represents the distances between a point from the set and random centroids. Then the argmin function is applied to identify the index of the min value in the set
    and the index is assigned to the data set as a "label" '''

    nested_lst = [eu_distance[i:i+num_of_clusters] for i in range(0, len(eu_distance), num_of_clusters)]
    label_lst = []
    for set in nested_lst:
        min_ind = np.argmin(set)
        label_lst.append(min_ind)

    # additional column is added to the initial dataSet containing the index of the min distance between a point in the set and the random centroids,
    # which represents the "label"(number of clusters)
    # converting dataSet into np array to add a label column into the nested list and converting it back to normal list
    dataset_nparray = np.array(dataSet1)
    dataset_nparray = np.insert(dataset_nparray, 3, label_lst, axis=1)
    dataSet1_lst = dataset_nparray.tolist() 

    return dataSet1_lst  

#====== Update the random centroids with mean centroids:

def calc_centroids(labeled_data):

    '''The functions calculates the means for each cluster generated by initial clustering. It takes the additional column as labels for the data, segregates it according to the
    index and returns the means for each cluster'''  

    d_x = []
    d_y = []
    d_l = []
    centroid_xy = []
    for i in range(0, len(labeled_data)):
        d_x.append(float(labeled_data[i][1]))
    d_x = np.array(d_x)
    for i in range(0,len(labeled_data)):
        d_y.append(float(labeled_data[i][2]))  
    d_y = np.array(d_y)

    for i in range(0,len(labeled_data)):
        d_l.append(int(labeled_data[i][3]))
    group = np.array(d_l) 

    for g in np.unique(group):  
        cluster = np.where(group == g) 
        x = mean(d_x[cluster]), mean(d_y[cluster])
        centroid_xy.append(x) 
    temp_lst  = [list(x) for x in centroid_xy]
      
    return(centroid_xy) 

def plot_data(d_x, d_y, group):

    '''The function plots the data from the data set, with different colors assigned for each cluster'''

    dataSet1_lst = min_dist()
    d_x = []
    d_y = []
    d_l = []
    # plot from the list
    for i in range(0, len(dataSet1_lst)):
        d_x.append(float(dataSet1_lst[i][1]))
    d_x = np.array(d_x)
    for i in range(0,len(dataSet1_lst)):
        d_y.append(float(dataSet1_lst[i][2]))  
    d_y = np.array(d_y)

    for i in range(0,len(dataSet1_lst)):
        d_l.append(int(dataSet1_lst[i][3]))
    group = np.array(d_l) 

    cdict = {0: 'red', 1: 'blue', 2:'green', 3: 'black', 4:'yellow'}
    # plot random centroids  
    for g in np.unique(group):
        ix = np.where(group == g)
        plt.scatter(d_x[ix], d_y[ix], c = cdict[g], label = g)

def plot_centroids(random_xy):
    '''The function plots the centroids in the same plot'''
    for i in range(len(random_xy)):
        plt.scatter(random_xy[i][0], random_xy[i][1], marker = 'x', c = 'black')   
    plt.xlabel("Birth Rate")
    plt.ylabel("Life expectancy")
    plt.yticks(np.arange(0, 100, 5))
    plt.xticks(np.arange(0, 70, 5))
    plt.show()

# =======
''' Main Function: the program reads csv file into a list, then a user inputs the number of clusters and random centroids are chosen to initialize the clusters,
after that the user inputs the number of iterations and with 'while loop' the code iterates through the dataset to find and adjust mean centroids '''

dataSet1 = read_csv(input('''Plese enter the file name you want to use: 
                    #data1953.csv
                   # data2008.csv
                   # dataBoth.csv \n''' ))
# Initalize cluster points
num_of_clusters = int(input("Input cluster amount:"))
# assign random points from the set as centroids:
random_xy = init_clusters(dataSet1, num_of_clusters) 
eu_distance = euclidean_dist_calc(dataSet1, random_xy) 

'''I commented out this part of code because I did not need it for the final result but as a check I want to have it available'''     
#for i in range(len(labeled_data)):
    #plot_data(labeled_data[i][1], labeled_data[i][2], labeled_data[i][3])

#plot_centroids(random_xy)

num_of_iterations = int(input("Input the number of iterations: "))

while num_of_iterations != 0:
    labeled_data = min_dist()
    centroid_xy = calc_centroids(labeled_data)
    eu_distance = euclidean_dist_calc(labeled_data, centroid_xy) 
    new_centered_data = min_dist()

    for i in range(len(new_centered_data)):
        plot_data(new_centered_data[i][1], new_centered_data[i][2], new_centered_data[i][3])

    plot_centroids(centroid_xy)
    num_of_iterations = num_of_iterations-1

# print mean life expectance and birth rate for each cluster

data_print = np.array(new_centered_data)
cluster = data_print[:,3]

birth_rate = (data_print[:,1])
birth_float = birth_rate.astype(float)

life_exp = data_print[:,2]
life_float = life_exp.astype(float)

for g in np.unique(cluster):  
    group = np.where(cluster == g) 
    mean_values = round(mean(birth_float[group]), 2), round(mean(life_float[group]),2)
    print("Mean birth rate and life expectancy in the cluster ", g,":", mean_values)

# print list of countries in each cluster

for g in np.unique(cluster):
    ix = np.where(cluster == g)
    print("Number of countries in the cluster ", g,":" , len(data_print[ix]))

# print the number of countries in each cluster

countries = data_print[:,0]
for g in np.unique(cluster):
    ix = np.where(cluster == g)
    print("Countries in the cluster ", g,":", countries[ix])

#===== end


    






